// backend/crc/routes/adminproduct.js
import express from "express";
import multer from "multer";
import path from "path";
import fs from "fs";
import { fileURLToPath } from "url";
import Product from "../../models/Product.js";

const router = express.Router();

// __dirname equivalent for ESM
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Multer storage: diskStorage storing to ./uploads (create uploads dir if missing)
const uploadDir = path.join(process.cwd(), "uploads");
if (!fs.existsSync(uploadDir)) {
  try { fs.mkdirSync(uploadDir, { recursive: true }); } catch (e) { console.warn("mkdir uploads failed", e); }
}

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const ts = Date.now();
    const safe = file.originalname.replace(/\s+/g, '-').replace(/[^a-zA-Z0-9._-]/g, '');
    cb(null, `${ts}-${safe}`);
  }
});
const upload = multer({ storage });

// Utility: convert uploaded file object to image metadata
function fileToImageMeta(file) {
  if (!file) return null;
  return {
    filename: file.filename,
    url: `/uploads/${file.filename}`, // static route should serve this path
    deleted: false
  };
}

/* --------------- Routes --------------- */

// GET /admin-api/products  -> list all non-deleted products
router.get("/", async (req, res) => {
  try {
    const products = await Product.find({ deleted: false }).sort({ createdAt: -1 }).lean().exec();
    return res.json(products);
  } catch (err) {
    console.error("list products error", err);
    return res.status(500).json({ ok: false, message: "Server error" });
  }
});

// GET /admin-api/products/:id -> single product
router.get("/:id", async (req, res) => {
  try {
    const p = await Product.findById(req.params.id).lean().exec();
    if (!p) return res.status(404).json({ ok: false, message: "Product not found" });
    return res.json(p);
  } catch (err) {
    console.error("get product error", err);
    return res.status(500).json({ ok: false, message: "Server error" });
  }
});

// POST /admin-api/products  -> create product with optional images
router.post("/", upload.array("images"), async (req, res) => {
  try {
    const {
      title, description = "", price = 0, mrp = 0, sku = "", stock = 0, brand = "", category = "",
      colors_json, sizes_json, videoUrl = ""
    } = req.body;

    if (!title || !String(title).trim()) {
      return res.status(400).json({ ok: false, message: "Title required" });
    }

    const colors = (() => {
      if (Array.isArray(req.body["colors[]"])) return req.body["colors[]"];
      if (colors_json) {
        try { return JSON.parse(colors_json); } catch (_) { return String(colors_json).split(",").map(s => s.trim()).filter(Boolean); }
      }
      return [];
    })();

    const sizes = (() => {
      if (Array.isArray(req.body["sizes[]"])) return req.body["sizes[]"];
      if (sizes_json) {
        try { return JSON.parse(sizes_json); } catch (_) { return String(sizes_json).split(",").map(s => s.trim()).filter(Boolean); }
      }
      return [];
    })();

    const images = (req.files || []).map(fileToImageMeta);

    const prod = new Product({
      title: String(title).trim(),
      description: String(description),
      price: Number(price) || 0,
      mrp: Number(mrp) || 0,
      sku: String(sku || ""),
      stock: Number(stock) || 0,
      brand: String(brand || ""),
      category: String(category || ""),
      images,
      colors,
      sizes,
      videoUrl: String(videoUrl || ""),
      deleted: false,
      ratings: []
    });

    const created = await prod.save();
    return res.status(201).json({ ok: true, product: created });
  } catch (err) {
    console.error("create product error", err);
    return res.status(500).json({ ok: false, message: "Server error" });
  }
});

// PUT /admin-api/products/:id -> update
router.put("/:id", upload.array("images"), async (req, res) => {
  try {
    const id = req.params.id;
    const existing = await Product.findById(id);
    if (!existing) return res.status(404).json({ ok: false, message: "Product not found" });

    const {
      title, description, price, mrp, sku, stock, brand, category,
      colors_json, sizes_json, videoUrl, existingImages
    } = req.body;

    if (title !== undefined) existing.title = String(title).trim();
    if (description !== undefined) existing.description = String(description);
    if (price !== undefined) existing.price = Number(price) || 0;
    if (mrp !== undefined) existing.mrp = Number(mrp) || 0;
    if (sku !== undefined) existing.sku = String(sku || "");
    if (stock !== undefined) existing.stock = Number(stock) || 0;
    if (brand !== undefined) existing.brand = String(brand || "");
    if (category !== undefined) existing.category = String(category || "");
    if (videoUrl !== undefined) existing.videoUrl = String(videoUrl || "");

    // Colors / sizes parsing
    if (colors_json !== undefined || req.body["colors[]"] !== undefined) {
      if (Array.isArray(req.body["colors[]"])) {
        existing.colors = req.body["colors[]"];
      } else if (colors_json) {
        try { existing.colors = JSON.parse(colors_json); } catch (_) { existing.colors = String(colors_json).split(",").map(s => s.trim()).filter(Boolean); }
      } else existing.colors = [];
    }

    if (sizes_json !== undefined || req.body["sizes[]"] !== undefined) {
      if (Array.isArray(req.body["sizes[]"])) {
        existing.sizes = req.body["sizes[]"];
      } else if (sizes_json) {
        try { existing.sizes = JSON.parse(sizes_json); } catch (_) { existing.sizes = String(sizes_json).split(",").map(s => s.trim()).filter(Boolean); }
      } else existing.sizes = [];
    }

    // existingImages is expected to be a JSON array of ids/urls to keep
    let keepList = [];
    if (existingImages) {
      try {
        keepList = Array.isArray(existingImages) ? existingImages : JSON.parse(existingImages || "[]");
      } catch (err) {
        keepList = [existingImages];
      }
    }

    // Build new images array: keep those that match keepList, plus newly uploaded files
    const kept = (existing.images || []).filter(img => {
      const idOrName = img._id ? String(img._id) : (img.filename || img.url);
      return keepList.length === 0 ? false : keepList.includes(idOrName) || keepList.includes(String(img._id)) || keepList.includes(img.filename) || keepList.includes(img.url);
    });

    const newImages = (req.files || []).map(fileToImageMeta);

    existing.images = [...kept, ...newImages];

    await existing.save();
    return res.json({ ok: true, product: existing });
  } catch (err) {
    console.error("update product error", err);
    return res.status(500).json({ ok: false, message: "Server error" });
  }
});

// DELETE /admin-api/products/:id -> soft delete
router.delete("/:id", async (req, res) => {
  try {
    const id = req.params.id;
    const p = await Product.findById(id);
    if (!p) return res.status(404).json({ ok: false, message: "Product not found" });
    p.deleted = true;
    await p.save();
    return res.json({ ok: true, message: "Product marked deleted" });
  } catch (err) {
    console.error("delete product error", err);
    return res.status(500).json({ ok: false, message: "Server error" });
  }
});

// POST /admin-api/products/:id/rate  -> add rating (1..5)
router.post("/:id/rate", express.json(), async (req, res) => {
  try {
    const id = req.params.id;
    let rating = req.body && (req.body.rating || req.body.value);
    if (rating === undefined || rating === null) {
      return res.status(400).json({ ok: false, message: "rating required" });
    }
    rating = parseInt(rating, 10);
    if (!Number.isInteger(rating) || rating < 1 || rating > 5) {
      return res.status(400).json({ ok: false, message: "rating must be integer 1..5" });
    }

    const p = await Product.findById(id);
    if (!p) return res.status(404).json({ ok: false, message: "Product not found" });

    p.ratings = Array.isArray(p.ratings) ? p.ratings : [];
    p.ratings.push(rating);
    await p.save();

    const avg = p.ratings.reduce((s, v) => s + Number(v || 0), 0) / p.ratings.length;
    return res.json({ ok: true, ratingCount: p.ratings.length, ratingAvg: avg, product: p });
  } catch (err) {
    console.error("rate product error", err);
    return res.status(500).json({ ok: false, message: "Server error" });
  }
});

export default router;
